# 有效的括号问题

![](https://cdn.maxlasting.com/doc-assets/202208231340328.jpg)

@ 金三（九）银四（十），又到了换工作的最佳时机，我幻想着只要跳个槽，就能离开这个”鸟地方“，拿着更多的钱，干着最爽的事...

> 然而现实总是残酷的，最近有个学妹在换工作，面试前什么手写Priomise、vue双向绑定原理,webpack优化方式,准备了一大堆，本以为成竹在胸，结果却在算法上吃了大亏，心仪的offer没有拿到，一度怀疑人生。到底是什么算法题能让面试官对妹子说出你都工作3年了，这个算法题都不会？这样的狠话？

## 题目描述

这是一道leetcode上的原题，本意是在考察候选人对栈数据结构的掌握。来看看题目：

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

示例：

```
示例 1：
输入：s = "()"
输出：true

示例 2：
输入：s = "()[]{}"
输出：true

示例 3：
输入：s = "(]"
输出：false

示例 4：
输入：s = "([)]"
输出：false

示例 5：
输入：s = "{[]}"
输出：true
```

## 解题信息

如果咱们确实没有刷过算法，不知道那么多套路，通过题目和示例尽可能的获取到更多的信息就很重要了。

根据题目推断出：

1. 字符串s的长度一定是偶数，不可能是奇数(一对对匹配)。
2. 右括号前面一定跟着左括号，才符合匹配条件，具备对称性。
3. 右括号前面如果不是左括号，一定不是有效的括号。

## 暴力消除法

得到了以上这些信息后，胖头鱼想既然是[]、{}、()成对的出现，我能不能把他们都挨个消除掉，如果最后结果是空字符串，那不就意味着符合题意了吗？

### 举个例子

```
输入：s = "{[()]}"

第一步：可以消除()这一对，结果s还剩{[]}

第二步: 可以消除[]这一对，结果s还剩{}

第三步: 可以消除{}这一对，结果s还剩'' 所以符合题意返回true
```

### 代码实现

```js
var isValid = (s) => {
  while (true) {
    let len = s.length
    // 将字符串按照匹配对，挨个替换为''
    s = s.replace('{}', '').replace('[]', '').replace('()', '')
    // 有两种情况s.length会等于len
    // 1. s匹配完了，变成了空字符串
    // 2. s无法继续匹配，导致其长度和一开始的len一样，比如({],一开始len是3，匹配完还是3，说明不用继续匹配了，结果就是false
    if (s.length === len) {
      return len === 0
    }
  }
}
```

暴力消除法最终还是可以通过leetcode的用例，就是性能差了点，哈哈！

![](https://cdn.maxlasting.com/doc-assets/202208231329964.png)

## 栈解题法

解题信息中的第2条强调对称性，而栈（后入先出）入栈和出栈恰好是反着来，形成了鲜明的对称性。

> 入栈：abc，出栈：cba

所以可以试试从栈的角度来解析：

```
输入：s = "{[()]}"

第一步：读取ch = {，属于左括号，入栈，此时栈内有{
第二步：读取ch = [，属于左括号，入栈，此时栈内有{[
第三步：读取ch = (，属于左括号，入栈，此时栈内有{[(
第四步：读取ch = )，属于右括号，尝试读取栈顶元素(和)正好匹配，将(出栈，此时栈内还剩{[
第五步：读取ch = ]，属于右括号，尝试读取栈顶元素[和]正好匹配，将[出栈，此时栈内还剩{
第六步：读取ch = }，属于右括号，尝试读取栈顶元素{和}正好匹配，将{出栈，此时栈内还剩''
第七步：栈内只能''，s = "{[()]}"符合有效的括号定义，返回true
```

### 代码实现

```js
var isValid = function(s) {
    if (!s) return false;
    const leftToRight = {
        '(': ')',
        '[': ']',
        '{': '}',
    };
    const stack = [];
    for (let i=0; i<s.length; i++) {
        const ch = s[i]
        if (leftToRight[ch]) {
            stack.push(ch)
        } else {
            if (!stack.length || leftToRight[stack.pop()] !== ch) {
                return false;
            }
        }
    }
    return !stack.length;
};
```

嗯，这回好多了：

![](https://cdn.maxlasting.com/doc-assets/202208231337721.png)

## 结尾

面试中，算法到底该不该成为考核候选人的重要指标咱们不吐槽，但是近几年几乎每个大厂都将算法放进了前端面试的环节，为了获得心仪的offer，重温数据结构，刷刷题还是很有必要的，愿你我都被算法温柔以待。

end!
